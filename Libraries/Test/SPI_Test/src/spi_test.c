//File: spi_test.c
//Project: Pico_MRI_Test_M

/* Description:

    This is a handler for testing the SPI-peripheral of RP2040 inside a MRI-Scanner.

        The test setup for SPI is:

        -Two Raspberry-Pi-Pico-Boards (Main and Sub)
        -Main sends out random generated bytes and send them to sub
        -Sub reads the bytes and send them back if main polls them
        -On main the TX and RX bytes are printed out and compared if they are equal
        -The number of transfers per test (per clock frequency) could be set, also the corresponding  clock frequency could be set
        -The number of bytes sent is 2 to the power of the actual transfer nr., plus two (so it makes sure to send atleast four bytes)
        -The four bytes are because as the slave needs to receive a rx interrupt wich only triggers if the FIFO-Buffer is half full (FIFO-Buffer length is 8 Byte)

*/


//Corresponding header-file:
#include "spi_test.h"

//Libraries:

//Standard-C:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

//Pico:

//Pico High-LvL-Libraries:
#include "pico/stdlib.h"
#include "pico/rand.h"

//Pico Hardware-Libraries:
#include "hardware/watchdog.h"

//Own Libraries:
#include "spi.h"
#include "uart.h"

//Preprocessor constants:

//File global (static) variables:


//Functions:

//File global (static) function definitions:

//Function definition:

int inline spi_test_echo_main(SPI_Test_Structure_t spi_tests, SPI_Test_Return_t *return_of_test, bool use_watchdog) {

    uint8_t tx_buffer[MAX_SPI_DATA_SIZE];

    clear_spi_buffer(tx_buffer);

    //Get random seed for rng
    uint32_t rng_seed = get_rand_32();
    //Set rng with seed
    srand((unsigned int)rng_seed);

    //Transfers: Get random tx-data and receive it back
    for(uint k = 0; k < spi_tests.parameter.number_of_transfers; k++) {

        //Clear result buffer
        clear_spi_buffer(return_of_test->tx_data_from_main_to_sub[k]);
        clear_spi_buffer(return_of_test->rx_data_from_sub_to_main[k]);
        clear_spi_buffer(tx_buffer);

        if(k > 0) {
            reconfigure_spi(spi_tests.hardware.spi_instance, (uint)spi_tests.parameter.parameter_clk_frequency, pow(2,k+2));
        }
        else {
            //TODO: Check for error in configuration and return
            //Configure SPI Hardware with frequency and write the real configured clock frequency to return of test spi_clk_frequency
            return_of_test->spi_clk_frequency = configure_spi_as_main(spi_tests.hardware.spi_instance, spi_tests.hardware.spi_miso_pin, spi_tests.hardware.spi_mosi_pin, 
            spi_tests.hardware.spi_clk_pin, spi_tests.hardware.spi_cs_pin, (uint)spi_tests.parameter.parameter_clk_frequency, pow(2,k+2));
        }

        //Get random tx data
        for(uint l = 0; l < pow(2, k+2); l++) {
            tx_buffer[l] = ((rand()%(255 - 1 + 1)) + 1);
            return_of_test->tx_data_from_main_to_sub[k][l] = tx_buffer[l];
        }

        //Send spi_tx_data to sub
        spi_main_tx_data(spi_tests.hardware.spi_instance, tx_buffer);
        if(use_watchdog) {
            watchdog_update();
        }

        //Wait for some time to give sub the time to write data to the output buffer
        busy_wait_us(55);

        //Poll data back from sub 
        spi_main_rx_data(spi_tests.hardware.spi_instance, return_of_test->rx_data_from_sub_to_main[k]);
        if(use_watchdog) {
            watchdog_update();
        }
        clear_spi_buffer(tx_buffer);

    }
    deconfigure_spi(spi_tests.hardware.spi_instance);

    return 1;

}//end spi_test_echo_main

void inline spi_test_echo_sub(SPI_Test_Structure_t spi_tests, bool use_watchdog)  {

    uint8_t count = 0;
    uint8_t rx_buffer[MAX_SPI_DATA_SIZE];
   
    clear_spi_buffer(rx_buffer);

    for(uint k = 0; k < spi_tests.parameter.number_of_transfers; k++) {

        if(k > 0) {
            reconfigure_spi(spi_tests.hardware.spi_instance, (uint) spi_tests.parameter.parameter_clk_frequency, pow(2,k+2));  
        }
        else {
            configure_spi_as_sub(spi_tests.hardware.spi_instance, spi_tests.hardware.spi_miso_pin, spi_tests.hardware.spi_mosi_pin, spi_tests.hardware.spi_clk_pin,
            spi_tests.hardware.spi_cs_pin, (uint)spi_tests.parameter.parameter_clk_frequency, pow(2,k+2));
        }
    
        while(count < 1 || spi_sub_get_rx_data_flag_status(spi_tests.hardware.spi_instance) == true || spi_get_tx_busy_flag_status(spi_tests.hardware.spi_instance) == true) {
            if(spi_sub_get_rx_data_flag_status(spi_tests.hardware.spi_instance) == true) {
                
                spi_sub_get_rx_data(spi_tests.hardware.spi_instance, rx_buffer);
                spi_sub_set_tx_busy_flag(spi_tests.hardware.spi_instance, true);
                spi_sub_set_tx_data(spi_tests.hardware.spi_instance, rx_buffer);
                clear_spi_buffer(rx_buffer);
                count++;
                if(use_watchdog) {
                    watchdog_update();
                }
                
            }
        };

        count = 0;
    }
    deconfigure_spi(spi_tests.hardware.spi_instance);
    
}//end spi_test_echo_sub

void spi_test_print_test_returns(SPI_Test_Return_t *test_return,  uint8_t num_of_tests, uart_inst_t *uart_to_print, SPI_Test_Output_Format_t format) {

    uint8_t out_buff[MAX_UART_DATA_SIZE];
    uint8_t transfer_byte_fail_counter = 0;
    uint8_t transfer_byte_success_counter = 0;
    float byte_fail_rate = 0;
    float byte_success_rate = 0;
   
    uart_tx_data(uart_to_print, "#################SPI-Test-Result-Print:######################");
    uart_tx_data(uart_to_print, "");
    sprintf(out_buff, "%ld tests performed with different clock frequencies. All tests are performed with Datasize from 4-Byte to %ld-Bytes", num_of_tests, (uint8_t)pow(2, 1+test_return[0].num_of_transfers));
    uart_tx_data(uart_to_print, out_buff);
    clear_uart_buffer(out_buff);
    uart_tx_data(uart_to_print, "");

    for(uint8_t n = 0; n < num_of_tests; n++) {
        sprintf(out_buff, "########################SPI-Test Nr: %ld############################", n+1);
        uart_tx_data(uart_to_print, out_buff);
        clear_uart_buffer;
        uart_tx_data(uart_to_print, "");
        uart_tx_data(uart_to_print, "#################SPI-Test-Parameter:#######################");
        sprintf(out_buff, "Clock-frequency: %ld", test_return[n].spi_clk_frequency);
        uart_tx_data(uart_to_print, out_buff);
        clear_uart_buffer(out_buff);
        uart_tx_data(uart_to_print, "");
        uart_tx_data(uart_to_print, "################Start-SPI-Test-Output-File#################");
        uart_tx_data(uart_to_print, "");
        uint8_t l = 0;
        
        for(uint k = 0; k < test_return[n].num_of_transfers; k++) {
                
            sprintf(out_buff, "#####################Transfer Nr. %ld, with %ld Bytes####################", k+1, (uint8_t) pow(2,k+2));
            uart_tx_data(uart_to_print, out_buff);
            clear_uart_buffer(out_buff);
            l = 0;
            for(uint j = 0; j < pow(2,k+2); j++) {

                if(l < format.bytes_per_line) {  
                    sprintf(out_buff, "TX: 0x%02X RX: 0x%02X%c" ,test_return[n].tx_data_from_main_to_sub[k][j], 
                    test_return[n].rx_data_from_sub_to_main[k][j], format.separator);
                    uart_tx_data_unterminated(uart_to_print, out_buff);
                    clear_uart_buffer(out_buff);
                    l++;
                }
                else {
                    uart_tx_data(uart_to_print, "");
                    sprintf(out_buff, "TX: 0x%02X RX: 0x%02X%c" ,test_return[n].tx_data_from_main_to_sub[k][j], 
                    test_return[n].rx_data_from_sub_to_main[k][j], format.separator);
                    uart_tx_data_unterminated(uart_to_print, out_buff);
                    clear_uart_buffer(out_buff);
                    l = 1;
                } 
                if(spi_compare_tx_rx(test_return[n].rx_data_from_sub_to_main[k][j], test_return[n].tx_data_from_main_to_sub[k][j])) {
                    transfer_byte_success_counter++;
                }
                else {
                    transfer_byte_fail_counter++; 
                }
            }//end byte loop

            byte_success_rate = (transfer_byte_success_counter/pow(2,k+2))*100;
            byte_fail_rate = (transfer_byte_fail_counter/pow(2,k+2))*100;
            transfer_byte_fail_counter = 0;
            transfer_byte_success_counter = 0;
            uart_tx_data(uart_to_print, "");
            sprintf(out_buff, "######Transfer-nr.%ld, byte-success-rate: %f%c, byte-fail-rate %f%c######", k+1, byte_success_rate, '%',
            byte_fail_rate, '%');
            uart_tx_data(uart_to_print, out_buff);
            clear_uart_buffer(out_buff);

        }//end transfer loop
        
        uart_tx_data(uart_to_print, "");
        uart_tx_data(uart_to_print, "################End-SPI-Test-Output-File#################");
    }
}//end spi_test_print_test_returns

bool spi_compare_tx_rx(uint8_t rx_data, uint8_t tx_data) {
    
    if(rx_data == tx_data) {
        return true;
    }
    return false;

}//end spi_compare_tx_rx

//end file spi_test.c
